# Next Step Instructions: Step 3.3 - Result Persistence and Job Management

**For**: Next Agent  
**Created**: 2025-10-30  
**Previous Step**: 3.2 - Configuration Management

## Context: What Was Just Completed

Step 3.2 created a comprehensive configuration management system with:

- DEFAULT_GA_CONFIG with all parameters from research Table 3
- Three preset configurations (FAST, BALANCED, THOROUGH)
- mergeConfig() for combining user overrides with defaults
- validateConfig() for parameter validation
- Fixed all type errors across test files
- Changed from elitismRate to eliteCount throughout the codebase

All test files now correctly import DEFAULT_GA_CONFIG from config.ts. The configuration system is ready to be consumed by higher-level orchestration code.

## What Step 3.3 Needs to Accomplish

Step 3.3 focuses on integrating the GA algorithm with the existing Job system to enable asynchronous timetable generation with proper status tracking, progress updates, and result persistence.

### Core Objectives

1. **Asynchronous Execution**: Run the GA algorithm without blocking the tRPC API response
2. **Status Tracking**: Update Job status throughout the GA execution lifecycle
3. **Progress Updates**: Report generation progress to the UI in real-time
4. **Result Persistence**: Convert the best chromosome into database records (LectureSlot, etc.)
5. **Error Handling**: Gracefully handle failures and report meaningful errors
6. **Cancellation Support**: Allow users to cancel long-running jobs

## Current State of the Codebase

### Job Model Already Exists

The Job model is defined in `prisma/schema/Job.prisma`:

- Fields: id, timetableId, status, progress, result, error, createdAt, startedAt, completedAt
- Status enum: PENDING, IN_PROGRESS, COMPLETED, FAILED, CANCELLED
- Already has tRPC endpoints for job management

### Existing Job Infrastructure

Check these files to understand the current job system:

- `src/server/trpc/routers/jobRouter.ts` - tRPC procedures for job CRUD
- `src/hooks/useJobs.tsx` - React hook for job status polling
- `src/routes/generate/*` - UI components for job display

### GA Components Ready to Use

All Phase 1, 2, and 3.1-3.2 components are complete:

- `algorithm.ts` - Main runGA() function ready to execute
- `config.ts` - Configuration system with validation
- All operators (initialization, selection, crossover, mutation, replacement)
- Fitness evaluation with caching
- Constraint checking infrastructure

## Implementation Strategy

### 1. Create Job Manager Module

**File**: `src/server/services/timetableGenerator/jobManager.ts`

This should be the orchestration layer between the Job system and the GA algorithm.

**Key Functions Needed**:

```
executeGenerationJob(jobId: string, timetableId: string, config?: PartialGAConfig)
  - Loads job from database
  - Updates status to IN_PROGRESS
  - Loads timetable data
  - Calls runGA() with progress callback
  - Persists results
  - Updates status to COMPLETED/FAILED

updateJobProgress(jobId: string, generation: number, maxGenerations: number, bestFitness: FitnessResult)
  - Calculate progress percentage
  - Update job.progress field
  - Optionally store intermediate results

persistResults(jobId: string, timetableId: string, bestChromosome: Chromosome, inputData: GAInputData)
  - Delete existing LectureSlot records for timetable
  - Create new LectureSlot records from chromosome
  - Mark isLocked for pre-assigned slots
  - Store fitness metrics in job.result JSON field

handleJobError(jobId: string, error: Error)
  - Log error details
  - Update job.status to FAILED
  - Store error message in job.error field
  - Clean up any partial results
```

### 2. Modify Generate Router

**File**: `src/server/trpc/routers/generateRouter.ts`

Update the generate procedure to:

- Create a Job record with status PENDING
- Trigger executeGenerationJob() asynchronously
- Return immediately with job ID (don't await GA completion)
- Let the client poll job status using existing job endpoints

### 3. Data Loading

You'll need to load complete timetable data for the GA. Create a helper function:

```
loadGAInputData(timetableId: string): Promise<GAInputData>
  - Load all lectures with subdivisions, allowedClassrooms, lockedSlots
  - Load all teachers with unavailableSlots
  - Load all subdivisions with unavailableSlots
  - Load all classrooms with unavailableSlots
  - Load all slots
  - Build lookup maps for O(1) access
  - Calculate total events (sum of lecture.count)
  - Generate event IDs
```

This function should use Prisma includes to fetch all relationships in minimal queries.

## Important Patterns to Follow

### Async Execution Pattern

```typescript
// In tRPC procedure (synchronous response)
const job = await prisma.job.create({ ... });

// Fire and forget (runs in background)
executeGenerationJob(job.id, timetableId, config).catch(error => {
  // Error already handled in executeGenerationJob
  console.error('Job execution failed:', error);
});

return { jobId: job.id }; // Return immediately
```

### Progress Callback Pattern

```typescript
const onProgress = (stats: GenerationStats) => {
  updateJobProgress(jobId, stats.generation, config.maxGenerations, stats);
};

await runGA(inputData, config, onProgress);
```

### Transaction Safety

Use Prisma transactions when persisting results to ensure atomicity:

```typescript
await prisma.$transaction(async (tx) => {
  // Delete old lecture slots
  await tx.lectureSlot.deleteMany({ where: { lecture: { timetableId } } });

  // Create new lecture slots
  await tx.lectureSlot.createMany({ data: newSlots });

  // Update job status
  await tx.job.update({ where: { id: jobId }, data: { status: 'COMPLETED', ... } });
});
```

## Data Transformation Details

### Chromosome to LectureSlot Mapping

Each Gene in the best chromosome represents a scheduled lecture event:

- Gene.lectureEventId format: "lectureId-evt0", "lectureId-evt1", etc.
- Extract lectureId by splitting on "-evt"
- Gene.timeslotId maps to Slot.id (already exists in DB)
- Gene.classroomId maps to Classroom.id (already exists in DB)

Create LectureSlot record:

- lectureId: extracted from Gene.lectureEventId
- slotId: Gene.timeslotId
- classroomId: Gene.classroomId (if specified)
- isLocked: Gene.isLocked (preserve user pre-assignments)

### Handling Multiple Lectures per Course

If a lecture has count=3, it produces 3 genes (lec1-evt0, lec1-evt1, lec1-evt2).
All three should create separate LectureSlot records pointing to the same lectureId.

### Fitness Metrics Storage

Store relevant fitness information in job.result JSON field:

- Best fitness score
- Hard constraint violations (count and types)
- Soft constraint violations (count and types)
- Is solution feasible?
- Total generations run
- Termination reason

## Testing Strategy

### Unit Tests

Create `__tests__/jobManager.test.ts` to test:

- Data loading function with mock Prisma data
- Chromosome to LectureSlot conversion logic
- Progress calculation
- Error handling scenarios

### Integration Tests

Manually test with:

1. Small timetable (5 lectures, 3 teachers, 2 classrooms)
2. Medium timetable (20 lectures)
3. Timetable with pre-assigned (locked) slots
4. Invalid timetable (impossible constraints)

Monitor:

- Job status updates in database
- Progress percentage calculation
- Final result correctness
- Error messages clarity

## Files to Create/Modify

### New Files

1. `src/server/services/timetableGenerator/jobManager.ts` (~300-400 lines)
2. `src/server/services/timetableGenerator/dataLoader.ts` (~200-300 lines)
3. `src/server/services/timetableGenerator/__tests__/jobManager.test.ts` (~200 lines)

### Files to Modify

1. `src/server/trpc/routers/generateRouter.ts` - Update generate procedure
2. `src/server/services/timetableGenerator/index.ts` - Export job manager functions

## Common Pitfalls to Avoid

### 1. Blocking the Event Loop

Don't await the GA execution in the tRPC procedure. Fire it off asynchronously and return the job ID immediately.

### 2. Not Handling Errors

Wrap executeGenerationJob in try-catch. Update job status to FAILED on any error. Don't let exceptions crash the Node process.

### 3. Forgetting Transactions

Always use transactions when deleting old results and creating new ones. Partial writes on failure will corrupt the timetable.

### 4. Not Validating Input

Before running GA, validate that the timetable has:

- At least one lecture
- At least one slot
- At least one classroom
  Fail fast with clear error if data is missing.

### 5. Memory Leaks

Don't hold references to large populations after GA completes. Let them be garbage collected.

### 6. Stale Job Status

Always reload job from database before checking status (for cancellation). Don't rely on stale in-memory references.

## Success Criteria

When Step 3.3 is complete:

- ✅ User can trigger timetable generation from UI
- ✅ Job starts and status updates to IN_PROGRESS
- ✅ Progress updates every generation (or every N generations)
- ✅ Upon completion, LectureSlot records are created in database
- ✅ Job status updates to COMPLETED with result metrics
- ✅ On failure, status updates to FAILED with error message
- ✅ User can view generated timetable in existing UI
- ✅ User can cancel long-running jobs
- ✅ Pre-assigned (locked) slots are preserved
- ✅ No type errors, all tests pass

## Questions to Consider

1. **How often to update progress?** Every generation is too frequent for large populations. Consider every 10 generations or every 5 seconds.

2. **Store intermediate results?** Could allow resuming failed jobs, but adds complexity. Start simple (no resume), can add later.

3. **Parallel job execution?** Current design assumes one job per timetable at a time. Should check if job already running before starting new one.

4. **Result validation?** After GA completes, should validate the generated timetable meets all hard constraints before marking as COMPLETED?

5. **Performance monitoring?** Consider logging generation time, fitness cache hit rate, etc. for optimization in future phases.

## References

- Research Section 5.2: Termination Conditions
- Research Section 7: Result Decoding
- `prisma/schema/Job.prisma`: Job model definition
- `src/server/trpc/routers/jobRouter.ts`: Existing job endpoints
- `src/hooks/useJobs.tsx`: Client-side job polling
- `memory-bank/tt-gen/steps.md`: Full implementation roadmap

## Final Notes

This step bridges the gap between the GA algorithm and the user-facing system. Take time to understand the existing Job infrastructure before implementing. The goal is seamless integration, not replacing what already works.

Good luck! Remember to update steps.md and create summary docs when complete.
