# Next Step Instructions: Step 5.2 - Integrate with Collections System

**Previous Step**: 5.1 - Create Generation UI Component  
**Next Step**: 5.2 - Integrate with Collections System  
**Prepared**: October 30, 2025

## Context from Step 5.1

The generation UI is now complete and functional. Users can:

- Configure GA parameters via presets or custom settings
- Start timetable generation jobs
- Monitor progress in real-time with live metrics
- View job history with results and quality reports

However, the generated timetable is NOT yet visible in the main timetable views. This is because:

1. Generation happens server-side and creates LectureSlot/LectureClassroom records
2. The UI components for viewing timetables don't yet exist or aren't connected
3. Collections need to refresh after generation completes
4. No mechanism exists for manual edits or locking slots

## What Step 5.2 Needs to Accomplish

### Primary Objective

Make the generated timetable visible and editable in the application's main views. Users should see a complete, usable weekly schedule grid after generation completes.

### Key Files to Examine First

1. **Existing Collections** (understand current data flow):
   - `src/db-collections/lectureSlotCollection.tsx` - Check if this exists
   - `src/db-collections/lectureClassroomCollection.tsx` - Check if this exists
   - `src/db-collections/providers/CollectionProvider.tsx` - See all registered collections

2. **Existing Timetable Views** (understand current UI):
   - Check `src/routes/tt/$timetableId/` directory for any existing timetable display routes
   - Look for components in `src/components/` that might display schedules
   - Search for "grid" or "calendar" components

3. **Decoder Output** (understand generated data structure):
   - `src/server/services/timetableGenerator/decoder.ts` - Review chromosomeToJSON output
   - `src/server/services/timetableGenerator/jobManager.ts` - See how results are persisted

4. **Prisma Models** (understand database schema):
   - `prisma/schema/Slot.prisma` - Timeslot structure
   - `prisma/schema/Lecture.prisma` - Lecture structure
   - Check if LectureSlot model exists or needs to be created

## Important Technical Context

### Collection Invalidation Pattern

The project uses TanStack Query under the hood (via TanStack DB Collections). When server data changes, you need to invalidate queries to trigger refetch. Pattern:

```typescript
import { useQueryClient } from "@tanstack/react-query";

const queryClient = useQueryClient();

// After generation completes
queryClient.invalidateQueries({
  queryKey: ["lectureSlot", timetableId],
});
```

The challenge: Where to trigger this invalidation?

- Option A: In useJobs hook after startGeneration succeeds
- Option B: In GenerationResults component when job completes
- Option C: In jobManager server-side (trigger client refresh via WebSocket/polling)

Recommendation: Option B - When GenerationResults detects status changed to COMPLETED, invalidate relevant collections. This keeps logic in UI layer.

### LectureSlot vs LectureClassroom

Based on decoder.ts implementation (from Step 4.1), generation creates:

- LectureSlot records: Map lecture to timeslot (lectureId + slotId)
- LectureClassroom records: Map lecture to classroom (lectureId + classroomId)

Check if these collections exist. If not, you'll need to create them following the pattern in existing collections.

### Multi-Session Lectures

Remember: A lecture with count=3 creates 3 separate LectureSlot records (one per session). The timetable grid needs to show all sessions of the same lecture, possibly with visual grouping or color coding.

### Cognitive Load Display

The project already has cognitive load tracking (`src/utils/cognitiveLoad.ts` and `src/db-collections/cognitiveLoadCollection.tsx`). The timetable view should display cognitive load warnings when subdivisions have excessive load in a day.

## Suggested Implementation Approach

### Phase 1: Create Missing Collections (if needed)

1. Check if lectureSlotCollection exists
2. If not, create following pattern:
   - Query: trpc.lectureSlot.list (get all LectureSlot for timetable)
   - Mutations: add, update, delete
   - Register in CollectionProvider

3. Same for lectureClassroomCollection if needed

### Phase 2: Build Timetable Grid Component

Create a new component (suggestion: `src/components/TimetableGrid/`) that:

- Takes lectures, slots, lectureSlots as props
- Renders a weekly grid (rows = slots/periods, cols = days)
- For each cell, shows which lecture is scheduled
- Uses Material-UI Table or custom grid
- Color codes by subject or subdivision
- Shows classroom assignment
- Highlights locked slots differently

Inspiration: Look at existing components in `src/components/` directory. There might be partial implementations or similar patterns.

### Phase 3: Create Timetable View Route

Create route at `src/routes/tt/$timetableId/view.tsx` (or similar) that:

- Uses useLiveQuery to get lectureSlots, lectures, slots, etc.
- Passes data to TimetableGrid component
- Shows loading state while collections load
- Handles empty state (no generation yet)

### Phase 4: Add Collection Invalidation

In GenerationResults component:

- Watch for job.status === "COMPLETED"
- When detected, invalidate lectureSlot and lectureClassroom collections
- This triggers automatic UI refresh

Pattern:

```typescript
const queryClient = useQueryClient();

useEffect(() => {
  if (job.status === "COMPLETED") {
    queryClient.invalidateQueries({ queryKey: ["lectureSlot", timetableId] });
    queryClient.invalidateQueries({
      queryKey: ["lectureClassroom", timetableId],
    });
  }
}, [job.status, timetableId]);
```

### Phase 5: Manual Edit Support

Add features to TimetableGrid:

- Click on cell to open edit dialog
- Change assigned classroom or timeslot
- Save changes via lectureSlot collection update
- Add "lock" button to prevent regeneration from changing this slot

For locked slots:

- Add `locked: boolean` field to LectureSlot model (requires Prisma migration)
- Update decoder to skip locked slots
- Visual indicator in grid (lock icon)

## Potential Challenges & Solutions

### Challenge 1: No Existing Timetable Grid

**If**: No component exists for displaying timetables in grid format
**Solution**: Build from scratch using Material-UI Table or create custom grid with Box/Grid components. Reference external timetable UIs for inspiration.

### Challenge 2: Complex Data Transformations

**If**: Going from normalized database (LectureSlot records) to grid view is complex
**Solution**: Create a utility function `buildTimetableGrid(lectures, slots, lectureSlots)` that returns a 2D array `grid[slotIndex][dayIndex] = { lecture, classroom }`. Then map over this in render.

### Challenge 3: Performance with Large Timetables

**If**: Rendering hundreds of cells causes lag
**Solution**: Use React.memo for grid cells, virtualization (react-window), or pagination by day/subdivision.

### Challenge 4: Collection Doesn't Auto-Refresh

**If**: Invalidating query doesn't trigger collection reload
**Solution**: Check CollectionProvider implementation. May need to manually call `collection.invalidate()` or `collection.refetch()` instead of queryClient.invalidateQueries.

### Challenge 5: Locked Slots Not Persisting

**If**: Prisma model doesn't have locked field
**Solution**: Add migration:

```prisma
model LectureSlot {
  // ... existing fields
  locked Boolean @default(false)
}
```

Then run `npx prisma db push` and `npx prisma generate`.

## Testing Strategy

1. **Manual Flow Test**:
   - Navigate to `/tt/{id}/generate`
   - Start generation with Fast preset
   - Wait for completion
   - Navigate to timetable view route
   - Verify schedule appears correctly

2. **Collection Refresh Test**:
   - Generate timetable
   - Keep timetable view open
   - Regenerate (overwrite)
   - Verify view updates automatically without manual refresh

3. **Manual Edit Test**:
   - Click on a scheduled lecture
   - Change its timeslot or classroom
   - Save
   - Verify change persists in database
   - Regenerate
   - Verify manual change was preserved (if locked)

4. **Edge Cases**:
   - Empty timetable (no generation yet)
   - Failed generation (error state)
   - Multi-session lectures display correctly
   - Cognitive load warnings appear

## Files You'll Likely Create/Modify

**New Files** (estimated):

- `src/components/TimetableGrid/TimetableGrid.tsx` (~200 lines)
- `src/components/TimetableGrid/TimetableCell.tsx` (~100 lines)
- `src/components/TimetableGrid/EditDialog.tsx` (~150 lines)
- `src/components/TimetableGrid/index.ts`
- `src/routes/tt/$timetableId/view.tsx` (~150 lines)
- `src/db-collections/lectureSlotCollection.tsx` (if missing, ~80 lines)
- `src/db-collections/lectureClassroomCollection.tsx` (if missing, ~80 lines)
- `src/utils/buildTimetableGrid.ts` (~100 lines)

**Modify Files**:

- `src/components/Generation/GenerationResults.tsx` - Add invalidation logic
- `src/db-collections/providers/CollectionProvider.tsx` - Register new collections
- `prisma/schema/Lecture.prisma` or create `LectureSlot.prisma` - Add locked field
- `src/server/trpc/routers/index.ts` - Register new routers if needed

**Total Estimate**: ~8-10 files, ~900 lines of code

## Success Criteria

Step 5.2 is complete when:

1. ✅ User can view generated timetable in a weekly grid format
2. ✅ Grid shows lectures, classrooms, and timeslots correctly
3. ✅ Collections automatically refresh when generation completes
4. ✅ User can manually edit individual lecture assignments
5. ✅ Manual edits persist through regeneration (locked slots)
6. ✅ Rollback mechanism allows reverting to previous timetable
7. ✅ All existing functionality (CRUD for lectures, teachers, etc.) still works
8. ✅ No TypeScript errors (npx tsc --noEmit passes)

## Resources to Review

- TanStack Query invalidation: https://tanstack.com/query/latest/docs/react/guides/query-invalidation
- Material-UI Table: https://mui.com/material-ui/react-table/
- Existing collection patterns in `src/db-collections/`
- Prisma schema patterns in `prisma/schema/`

## Final Notes

This step bridges server-side generation with client-side visualization. The key is making data flow seamless:

1. Server generates → Stores in DB → Client fetches via collections → Renders in grid
2. User edits → Collections update → Server saves → Grid refreshes

Follow the existing patterns in the codebase (Collections → tRPC → Prisma) and you'll maintain architectural consistency. The generation UI from Step 5.1 is already solid - now just make the results visible and useful.

Good luck! The timetable grid will be the most user-visible part of the entire system.
