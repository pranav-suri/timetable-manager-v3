### Next Step Instructions for Step 3.1 - Implement Main GA Loop

**Context**: With the completion of all core genetic operators (initialization, selection, crossover, mutation, and replacement), Phase 2 is now complete. The next logical step is to integrate these individual components into a cohesive evolutionary process. Step 3.1 involves creating the main algorithm loop that orchestrates the entire timetable generation process from start to finish.

**Objective**: Your task is to implement the main GA loop in a new file, `src/server/services/timetableGenerator/algorithm.ts`. This file will be the engine that drives the evolution.

**Key Files to Examine First**:

1.  `memory-bank/tt-gen/steps.md`: Review the requirements for Step 3.1 for a detailed breakdown.
2.  `src/server/services/timetableGenerator/types.ts`: Re-familiarize yourself with the core data structures like `Population`, `GAConfig`, and `FitnessResult`.
3.  `src/server/services/timetableGenerator/initialization.ts`: You will use `initializePopulation` to create the starting population.
4.  `src/server/services/timetableGenerator/fitness.ts`: You will need `evaluatePopulation` and `findBestChromosome`.
5.  `src/server/services/timetableGenerator/selection.ts`: You will use the tournament selection implementation to select parents.
6.  `src/server/services/timetableGenerator/crossover.ts`: Use this to create offspring from the selected parents.
7.  `src/server/services/timetableGenerator/mutation.ts`: Use this to mutate the generated offspring.
8.  `src/server/services/timetableGenerator/replacement.ts`: You will use `performReplacement` to create the next generation.

**Implementation Guidance**:

1.  **Create `algorithm.ts`**: This new file will export a main function, e.g., `runGA`.
2.  **Function Signature**: The main function should accept the `GAInputData` and `GAConfig` as parameters and will likely be asynchronous to support progress updates.
3.  **Algorithm Flow**: Structure your implementation to follow the classic GA loop:
    a. Initialize the population.
    b. Evaluate the fitness of the initial population.
    c. Loop for `maxGenerations` or until a termination condition is met:
    i. Select parents.
    ii. Create offspring via crossover.
    iii. Mutate offspring.
    iv. Evaluate fitness of the new offspring.
    v. Create the next generation using the replacement strategy (elitism).
    vi. Update population and fitnesses for the next iteration.
    vii. Track statistics (best fitness, etc.) and check for termination (e.g., stagnation).
4.  **Termination**: For now, focus on the `maxGenerations` and stagnation limits. Job cancellation and other advanced termination conditions will be handled in later steps.

**Gotchas & Important Considerations**:

- **State Management**: Be mindful of how you manage the population and fitness results from one generation to the next. Ensure you are passing the correct data to each operator.
- **Asynchronicity**: While the core GA loop is synchronous, the function wrapping it should be `async` to allow for future non-blocking operations like progress reporting (Step 3.3).
- **Performance**: You are now combining all the pieces. Keep an eye on the performance targets. The loop itself should be efficient, with the bulk of the computation time spent in fitness evaluation.
