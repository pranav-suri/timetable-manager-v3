# Next Step Instructions: Phase 2 - GA Core Components

**For**: Agent implementing Steps 2.1-2.6  
**Date**: October 29, 2025  
**Context**: Foundation (Phase 1) is complete - all types, data loading, and constraint checking implemented

## What You're Building Next

You're implementing the **Genetic Algorithm Core Components** - the actual evolution operators that will search the solution space. This phase transforms the foundation into a working optimization engine.

## Critical Files to Review First

### 1. Understanding the Foundation (15 minutes)

**Read these files in order**:

1. `src/server/services/timetableGenerator/types.ts`
   - Lines 1-100: Extended input types and chromosome representation
   - Lines 100-200: Constraint violation types and enums
   - Lines 200-300: Fitness evaluation and GA configuration
   - Lines 400-500: DEFAULT_GA_CONFIG - use these values as starting points

2. `memory-bank/tt-gen/research.md`
   - Section 3: Fitness Function (hierarchical penalty)
   - Section 4.1: Population Initialization (random + heuristic)
   - Section 4.2: Selection (tournament with niched-penalty)
   - Section 4.3: Crossover (uniform with repair)
   - Section 4.4: Mutation (swap + random reset)
   - Section 4.5: Elitism and replacement strategy

3. `src/server/services/timetableGenerator/constraints.ts`
   - Line 795: `evaluateChromosome` function - you'll call this extensively
   - Line 835: `compareChromosomes` function - use for tournament selection
   - Understand that fitness calculation is ALREADY DONE - don't reimplement

### 2. Key Concepts to Internalize

**Chromosome Structure**:

- A chromosome is an array of genes (type `Chromosome = Gene[]`)
- Each gene represents ONE scheduled event: `{ lectureEventId, lectureId, timeslotId, classroomId, isLocked, duration }`
- Chromosome length is FIXED = total number of events to schedule (sum of all lecture.count)
- Example: If you have 3 lectures with counts [2, 1, 3], chromosome has exactly 6 genes

**Event IDs**:

- Each lecture with count=N generates N events: `lectureId-evt0`, `lectureId-evt1`, ..., `lectureId-evt(N-1)`
- These event IDs are in `lookupMaps.eventToLecture` - use this to get lecture metadata
- Locked events have `gene.isLocked = true` and should maintain their `timeslotId`

**Lookup Maps Are Your Friend**:

- `inputData.lookupMaps` contains 14 pre-built maps for O(1) access
- `lectureToAllowedClassrooms` - get valid classrooms for a lecture
- `slotIdToSlot` - get slot metadata (day, period)
- `lockedAssignments` - check if an event has pre-assigned slot
- NEVER iterate through full arrays when a map exists

**Fitness is Hierarchical**:

- Hard violations ALWAYS dominate soft violations (weight = 1000 vs 1-10)
- A solution with 1 hard violation is worse than ANY solution with 0 hard violations
- Use `compareChromosomes(fitness1, fitness2)` - it implements the rules correctly
- Don't compare `fitnessScore` directly - use the comparison function

## Implementation Order (Follow Strictly)

### Step 2.1: Fitness Function (Already Done!)

**IMPORTANT**: The fitness function is ALREADY IMPLEMENTED in `constraints.ts`:

- `evaluateChromosome(chromosome, inputData, weights)` returns `FitnessResult`
- `compareChromosomes(fitness1, fitness2)` returns 1/-1/0

**What YOU need to implement**:

- A wrapper function that caches fitness results (optional optimization)
- Integration with the population evaluation loop (you'll write this in Step 3.1)

**Do NOT reimplement fitness calculation** - just use the existing function.

### Step 2.2: Population Initialization ⭐ START HERE

**File**: `src/server/services/timetableGenerator/initialization.ts`

**Objective**: Generate initial population of diverse chromosomes

**Implementation Strategy**:

1. **Random Initialization** (80% of population by default):

   ```typescript
   function initializeRandomChromosome(inputData: GAInputData): Chromosome;
   ```

   - For each event in sequence (from `inputData.totalEvents`)
   - Get event ID and corresponding lecture
   - If event is locked: use locked slot/classroom
   - Else: randomly select from allowed classrooms and available slots
   - Return complete chromosome

2. **Heuristic Initialization** (20% of population):

   ```typescript
   function initializeHeuristicChromosome(inputData: GAInputData): Chromosome;
   ```

   - Use greedy heuristic: schedule events that have fewest valid options first
   - For each event: select slot/classroom that minimizes conflicts with already-scheduled events
   - This gives better starting solutions than pure random

3. **Main Function**:

   ```typescript
   function initializePopulation(
     config: GAConfig,
     inputData: GAInputData,
   ): Population;
   ```

   - Create `config.populationSize` chromosomes
   - `config.heuristicInitRatio * populationSize` use heuristic
   - Remainder use random
   - Shuffle to mix random and heuristic chromosomes

**Critical Details**:

- Respect locked assignments: `if (gene.isLocked) { use gene.timeslotId }`
- Use `lookupMaps.lectureToAllowedClassrooms.get(lectureId)` for valid classrooms
- For random selection, use `Math.random()` or better: pass a seed for reproducibility
- Handle edge case: lecture has no allowed classrooms → use all classrooms

**Testing Checklist**:

- [ ] All chromosomes have correct length (= totalEvents)
- [ ] All locked genes maintain their assignments
- [ ] All genes have valid classroom IDs (in allowed list)
- [ ] Heuristic initialization produces better fitness than random (on average)

### Step 2.3: Tournament Selection

**File**: `src/server/services/timetableGenerator/selection.ts`

**Objective**: Select parents for reproduction using tournament selection

**Implementation**:

```typescript
function tournamentSelection(
  population: Population,
  fitnessResults: FitnessResult[],
  tournamentSize: number,
): Chromosome;
```

**Algorithm**:

1. Randomly select `tournamentSize` indices from population (default 3)
2. Get fitness results for these chromosomes
3. Use `compareChromosomes` to find the best among them
4. Return the winning chromosome (NOT its index, the actual chromosome)

**Why Tournament**:

- Simple to implement
- Provides selection pressure (better chromosomes more likely to be selected)
- Tournament size controls pressure: larger = more elitist, smaller = more diverse

**Edge Cases**:

- If tournament size > population size: use population size
- Ensure random selection is uniform (don't bias toward early indices)

### Step 2.4: Crossover Operator

**File**: `src/server/services/timetableGenerator/crossover.ts`

**Objective**: Combine two parent chromosomes to create offspring

**Implementation**:

```typescript
function uniformCrossover(
  parent1: Chromosome,
  parent2: Chromosome,
  inputData: GAInputData,
  enableRepair: boolean = true,
): Chromosome;
```

**Algorithm (Uniform Crossover)**:

1. For each gene position i:
   - With 50% probability: take gene from parent1
   - Otherwise: take gene from parent2
2. CRITICAL: If gene is locked, ALWAYS use the locked assignment (ignore parents)
3. If `enableRepair = true`: run repair operator after crossover

**Repair Operator** (essential for quality):

```typescript
function repairChromosome(
  chromosome: Chromosome,
  inputData: GAInputData,
): Chromosome;
```

- Evaluate chromosome to find violations
- For each hard violation (clash, unavailability):
  - Identify conflicting genes
  - Randomly reassign ONE of them to a different slot/classroom
- Limit repair iterations (e.g., max 10 attempts)
- Research Section 4.3.2 provides details

**Why Repair**:

- Crossover often creates invalid schedules (teacher clashes, room conflicts)
- Repair fixes obvious violations without destroying good patterns
- Dramatically improves convergence speed

### Step 2.5: Mutation Operator

**File**: `src/server/services/timetableGenerator/mutation.ts`

**Objective**: Introduce random changes to maintain diversity

**Implementation**:

```typescript
function mutateChromosome(
  chromosome: Chromosome,
  inputData: GAInputData,
  swapMutationRatio: number = 0.9,
): Chromosome;
```

**Algorithm**:

1. For each gene in chromosome:
   - With probability `config.mutationProbability` (default 0.05):
     - If gene is locked: skip (don't mutate locked assignments)
     - With probability `swapMutationRatio` (default 0.9): **Swap Mutation**
       - Select another random gene from chromosome
       - Swap their timeslots and classrooms
     - Else: **Random Reset Mutation**
       - Assign random valid slot from available slots
       - Assign random classroom from allowed classrooms

**Why Two Mutation Types**:

- Swap preserves overall slot/classroom distribution (good for local search)
- Random reset can escape local optima (good for diversity)
- 90/10 ratio balances exploitation vs exploration

**Edge Cases**:

- If mutating would violate locked constraint: skip that mutation
- Ensure random selections are from VALID options (allowed classrooms, available slots)

### Step 2.6: Elitism and Replacement

**File**: `src/server/services/timetableGenerator/replacement.ts`

**Objective**: Combine parents and offspring into next generation

**Implementation**:

```typescript
function selectNextGeneration(
  currentPopulation: Population,
  currentFitness: FitnessResult[],
  offspring: Population,
  offspringFitness: FitnessResult[],
  eliteCount: number,
): { population: Population; fitness: FitnessResult[] };
```

**Algorithm (Elitist Replacement)**:

1. Sort current population by fitness using `compareChromosomes`
2. Keep top `eliteCount` chromosomes (default 4 = 2% of 200)
3. Fill remaining slots with offspring (sorted by fitness)
4. Return new population + corresponding fitness results

**Why Elitism**:

- Guarantees best solution never degrades between generations
- Small elite count (2-5%) is sufficient
- Too much elitism (>10%) reduces diversity

## Critical Gotchas & Common Mistakes

### Mistake 1: Mutating Locked Genes

```typescript
// ❌ WRONG
gene.timeslotId = randomSlot; // Might violate locked constraint

// ✅ CORRECT
if (!gene.isLocked) {
  gene.timeslotId = randomSlot;
}
```

### Mistake 2: Not Using Lookup Maps

```typescript
// ❌ WRONG - O(n²)
for (const classroom of inputData.classrooms) {
  if (lecture.allowedClassrooms.includes(classroom.id)) { ... }
}

// ✅ CORRECT - O(1)
const allowedClassrooms = inputData.lookupMaps.lectureToAllowedClassrooms.get(lecture.id);
```

### Mistake 3: Comparing Fitness Incorrectly

```typescript
// ❌ WRONG
if (fitness1.fitnessScore > fitness2.fitnessScore) { ... }

// ✅ CORRECT
if (compareChromosomes(fitness1, fitness2) > 0) { ... }
```

### Mistake 4: Modifying Original Chromosomes

```typescript
// ❌ WRONG - mutates parent
function crossover(parent1, parent2) {
  parent1[0] = parent2[0]; // MUTATES PARENT!
}

// ✅ CORRECT - create new array
function crossover(parent1, parent2) {
  const offspring = parent1.map((gene, i) =>
    Math.random() < 0.5 ? { ...gene } : { ...parent2[i] },
  );
}
```

### Mistake 5: Not Preserving Event Order

```typescript
// ❌ WRONG - events must stay in same order
chromosome.sort(() => Math.random() - 0.5);

// ✅ CORRECT - only modify gene properties, not array order
chromosome.forEach((gene) => {
  gene.timeslotId = newSlot;
});
```

## Testing Strategy

For each operator, test:

1. **Structural Validity**: Output chromosome has correct length, all event IDs present
2. **Constraint Preservation**: Locked genes remain locked, valid classroom assignments
3. **Diversity**: Random operators produce different results on multiple runs
4. **Improvement**: Heuristic operators should improve fitness vs random
5. **Performance**: Each operator should complete in <100ms for 200-event chromosome

All the pieces you're building in Phase 2 plug directly into this loop.

## Quick Reference: Key Functions You'll Call

From existing code:

- `evaluateChromosome(chromosome, inputData, weights)` → FitnessResult
- `compareChromosomes(fitness1, fitness2)` → 1/-1/0
- `loadTimetableData(timetableId, prisma)` → GAInputData

From your Phase 2 code:

- `initializePopulation(config, inputData)` → Population
- `tournamentSelection(population, fitness, k)` → Chromosome
- `uniformCrossover(p1, p2, inputData, repair)` → Chromosome
- `mutateChromosome(chromosome, inputData, ratio)` → Chromosome
- `selectNextGeneration(pop, fit, offspring, offFit, elite)` → {pop, fit}

## Start Here

1. Open `src/server/services/timetableGenerator/initialization.ts` (create new file)
2. Import types: `import type { Chromosome, Gene, Population, GAConfig, GAInputData } from "./types"`
3. Implement `initializeRandomChromosome` first (simplest case)
4. Test with sample data from database
5. Then implement `initializeHeuristicChromosome`
6. Finally `initializePopulation` to combine them

Good luck! The foundation is solid - now make it evolve! 🧬
