# Next Step Instructions: Phase 6 - Advanced Enhancements

**Previous Step**: 5.2 - Integrate with Collections System (Cancelled/Simplified)  
**Next Steps**: Phase 6 - Advanced Enhancements (Optional)  
**Prepared**: October 30, 2025

## Current Project State

The timetable generation system is now **functionally complete** for production use:

✅ **Core GA Implementation** (Phases 1-3):

- All genetic operators implemented and tested
- Fitness evaluation with hierarchical constraint handling
- Main evolutionary loop with termination conditions
- Job management with progress tracking
- Result persistence to database

✅ **User Interface** (Phase 5):

- Generation control panel with presets and advanced options
- Real-time progress monitoring with live statistics
- Job history with results and quality reports
- Complete timetable editor with drag-and-drop
- Automatic UI refresh after generation

✅ **Data Integration**:

- Collections system fully integrated
- LectureSlot and LectureClassroom models properly used
- Lock/unlock functionality for preserving manual edits
- Conflict detection and display

## What Phase 6 Offers

Phase 6 contains **optional enhancements** that improve quality, performance, or user experience but are NOT required for basic functionality. Consider these if:

- Generation quality is insufficient for complex timetables
- Generation is too slow for large problem sizes
- Users request specific advanced features
- You have development time to invest in optimization

### Step 6.1 - Local Search Hybridization (Memetic Algorithm)

**What It Does**: Adds hill-climbing local search after crossover/mutation to refine solutions faster.

**When to Implement**:

- If GA gets stuck in local optima (fitness plateaus early)
- If soft constraint violations remain high in final solution
- If you have 20+ lectures and want faster convergence

**Complexity**: Medium (5-6 hours)

**Benefits**:

- Typically 20-40% faster convergence to good solutions
- Better final fitness (fewer soft violations)
- Standard enhancement in modern GAs

**Trade-offs**:

- Increases per-generation computation time (~30%)
- May reduce population diversity if overused
- Requires parameter tuning (local search intensity)

**Key Files to Understand First**:

- `src/server/services/timetableGenerator/algorithm.ts` - Where to inject local search
- `src/server/services/timetableGenerator/mutation.ts` - Similar neighborhood moves
- Research Section 6.1 - Theory and algorithms

**Implementation Approach**:

1. Create `localSearch.ts` with hill climbing function
2. Define neighborhood moves (swap genes, shift timeslot, change classroom)
3. Integrate into main loop: apply to top 20% of offspring
4. Add config parameters: `localSearchEnabled`, `localSearchIterations`
5. Test impact on convergence speed and final quality

### Step 6.2 - Domain-Specific Heuristics

**What It Does**: Incorporates real-world knowledge to improve generation quality.

**When to Implement**:

- If cognitive load is frequently unbalanced
- If multi-session lectures are poorly scheduled
- If classroom utilization is suboptimal
- If users have specific institutional requirements

**Complexity**: Medium-High (6-8 hours)

**Benefits**:

- Better alignment with institutional needs
- Reduced soft constraint violations
- More "sensible" timetables (even if fitness is similar)

**Trade-offs**:

- Highly problem-specific (may need customization per institution)
- Can introduce bias that limits GA exploration
- Requires domain knowledge input

**Key Enhancements Available**:

1. **Cognitive Load Balancing**:
   - Existing: `src/utils/cognitiveLoad.ts` has calculation logic
   - Enhancement: Bias initial population toward balanced days
   - In repair: Move lectures to less loaded days preferentially
   - Impact: Students have more even study distribution

2. **Consecutive Preference Optimization**:
   - Current: Soft constraint penalizes gaps
   - Enhancement: Actively cluster lectures for same subdivision
   - Repair: When fixing clash, try adjacent slots first
   - Impact: Fewer gaps, better student experience

3. **Classroom Optimization**:
   - Current: Random classroom assignment in initialization
   - Enhancement: Match lecture enrollment to room capacity
   - Prefer same room for same teacher (reduce movement)
   - Impact: Better space utilization, less teacher travel

4. **Duration Handling for Multi-Slot Lectures**:
   - Current: Each session scheduled independently
   - Enhancement: Ensure consecutive slots on same day
   - Avoid splitting across breaks
   - Impact: Lectures don't get fragmented

5. **Pre-Assignment and Locking**:
   - Current: `isLocked` field exists but not used in GA
   - Enhancement: Lock genes in chromosome, skip in mutation
   - Seed population with existing timetable
   - Impact: Incremental re-optimization, preserve manual work

**Implementation Priority Order**:

1. Pre-assignment/Locking (most requested, easiest)
2. Cognitive Load Balancing (uses existing code)
3. Duration Handling (prevents common errors)
4. Classroom Optimization (polish, not critical)
5. Consecutive Preference (already handled by soft constraint)

**Files to Examine**:

- `src/server/services/timetableGenerator/initialPopulation.ts` - Greedy heuristic location
- `src/server/services/timetableGenerator/repair.ts` - Repair strategy location
- `src/utils/cognitiveLoad.ts` - Cognitive load logic
- Research Section 6.3 - Domain heuristic patterns

### Step 6.3 - Parallel Execution Support (Optional)

**What It Does**: Runs multiple independent GAs in parallel, exchanges best solutions.

**When to Implement**:

- If single generation takes >5 minutes
- If you have 50+ lectures to schedule
- If server has multiple CPU cores available
- If users are willing to wait for near-optimal results

**Complexity**: High (6-8 hours)

**Benefits**:

- Near-linear speedup with number of cores (4 cores ≈ 3x faster)
- Better exploration of solution space (diversity)
- Can use different parameters per island

**Trade-offs**:

- Complex implementation (worker threads, serialization)
- Memory overhead (multiple populations)
- Diminishing returns beyond 8 cores
- Requires Node.js worker_threads (supported)

**Implementation Approach**:

1. Study Node.js worker_threads API
2. Create `parallel.ts` with island model
3. Split population into N islands
4. Run GA in each worker
5. Migrate best individuals every M generations
6. Merge results at end

**Only Implement If**: Single-threaded GA is too slow for your use case.

## Recommended Next Steps

### Option A: Production Deployment (Recommended)

If core functionality meets your needs:

1. **Deploy to Production**:
   - Test end-to-end with real data
   - Monitor job success rate
   - Collect user feedback
   - Identify actual pain points

2. **Polish Existing Features**:
   - Add snackbar notifications
   - Improve error messages
   - Add loading skeletons
   - Implement rollback mechanism (Step 5.2 requirement)

3. **Documentation**:
   - User guide for generation parameters
   - FAQ for common issues
   - Video tutorial for non-technical users

4. **Return to Phase 6 Later**: Based on real-world usage, prioritize enhancements.

### Option B: Implement Phase 6 Enhancements

If generation quality/speed is insufficient:

**Start with Step 6.2 (Domain Heuristics)** - specifically:

1. **Locked Slot Preservation** (2 hours):
   - Modify initialization to respect `isLocked=true`
   - Skip locked genes in mutation
   - Test regeneration with locked slots
   - Immediate user value (preserve manual work)

2. **Cognitive Load Balancing** (2 hours):
   - Modify greedy initialization to balance load
   - Add load check in repair strategies
   - Test with real subdivision data
   - Improves student experience

3. **Then Step 6.1 (Local Search)** if needed (5 hours):
   - Implement hill climbing
   - Integrate into main loop
   - Benchmark convergence improvement
   - Deploy if significant benefit

**Skip Step 6.3 (Parallel)** unless absolutely necessary. Single-threaded GA should handle 100+ lectures reasonably well (~2-3 minutes with balanced preset).

## Implementation Guidelines for Phase 6

### Before Starting Any Step

1. **Benchmark Current Performance**:
   - Generate timetables with Fast/Balanced/Thorough presets
   - Record: time to feasible solution, final fitness, constraint violations
   - Identify bottlenecks (is it time? quality? specific constraints?)

2. **Define Success Criteria**:
   - What improvement would justify the effort?
   - Example: "Reduce soft violations by 30%" or "Generate in <1 minute"
   - Measure objectively before and after

3. **Consult Research Document**:
   - `memory-bank/tt-gen/research.md` has theoretical foundation
   - Understand why each enhancement works
   - Follow proven patterns, don't invent

### During Implementation

1. **Preserve Existing Functionality**:
   - Don't break current GA
   - Make enhancements optional (config flags)
   - Test with `localSearchEnabled=false` to ensure baseline works

2. **Measure Impact**:
   - Run same problem before and after
   - Compare: convergence speed, final fitness, violations
   - Document improvements in commit message

3. **Consider Config Exposure**:
   - Should users control this enhancement?
   - Add to advanced options if yes
   - Keep defaults sensible for average user

### Testing Strategy

1. **Unit Tests**:
   - Test each enhancement function independently
   - Verify neighborhood moves are valid
   - Check local search converges

2. **Integration Tests**:
   - Run full GA with enhancement enabled
   - Verify no regressions
   - Compare quality metrics

3. **Real-World Tests**:
   - Use actual institution's data
   - Generate multiple times (stochastic)
   - Validate constraints still hold

## Potential Challenges & Solutions

### Challenge: Local Search Too Slow

**Symptom**: Per-generation time doubles, overall worse
**Solution**: Reduce `localSearchIterations` or apply selectively (top 10% offspring)
**Fallback**: Skip local search, not critical

### Challenge: Locked Slots Cause Infeasibility

**Symptom**: Can't find valid assignments around locked genes
**Solution**: Unlock some slots, or warn user before generation
**Pattern**: Check feasibility before starting GA

### Challenge: Domain Heuristics Reduce Diversity

**Symptom**: Population converges too fast, gets stuck
**Solution**: Only apply heuristics to 50% of initial population
**Balance**: Exploration (random) vs exploitation (heuristic)

### Challenge: Parallel Implementation Crashes

**Symptom**: Worker threads fail, serialization errors
**Solution**: Simplify data passed to workers, add error handling
**Alternative**: Use process-based parallelism instead of threads

## Resources & References

### Code to Review

- `src/server/services/timetableGenerator/algorithm.ts` - Main loop
- `src/server/services/timetableGenerator/initialPopulation.ts` - Where heuristics go
- `src/server/services/timetableGenerator/repair.ts` - Repair patterns
- `src/server/services/timetableGenerator/config.ts` - Add new parameters

### Research Sections

- Section 6.1 - Memetic Algorithms
- Section 6.2 - Parallel Genetic Algorithms
- Section 6.3 - Domain-Specific Heuristics
- Section 5 - Parameter Tuning (if adding new params)

### External Resources

- Node.js worker_threads docs (for parallel)
- Simulated annealing algorithms (alternative to hill climbing)
- Timetabling problem benchmarks (compare your results)

## Decision Matrix: Should You Implement Phase 6?

**YES, implement enhancements if**:

- Generation takes >3 minutes for your problem size
- Soft violations consistently >20% of total penalty
- Users complain about quality (despite feasible solutions)
- You have locked slot requirements
- Institution has specific domain rules

**NO, skip Phase 6 if**:

- Current GA produces good timetables in <2 minutes
- Violations are acceptably low
- Users are satisfied with quality
- You have limited development time
- Need to focus on other features

**MAYBE, consider later if**:

- Works for now but could be better
- Want to benchmark against literature
- Planning to publish results
- Have development capacity after MVP

## Final Recommendation

**For Most Projects**: Deploy current implementation, gather real usage data, then decide on enhancements based on actual needs rather than theoretical improvements.

**Priority Enhancement**: Locked slot preservation (Step 6.2.6) - Easy win, high user value.

**Skip**: Parallel execution (Step 6.3) unless problem size exceeds 200 lectures.

Phase 5 is complete. The system works end-to-end. Phase 6 is for optimization, not core functionality. Choose enhancements strategically based on real-world requirements.
