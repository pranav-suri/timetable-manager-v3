# Next Step Instructions: Step 4.1 - Implement Chromosome Decoder

**For**: Next Agent
**Created**: 2025-10-30
**Previous Step**: 3.3 - Result Persistence and Job Management

## Context: What Was Just Completed

Step 3.3 has fully integrated the GA engine with the application's job system. The `jobManager.ts` now handles asynchronous execution, status updates, and result persistence. The `generateRouter.ts` can successfully launch a background generation job. However, the `persistResults` function in `jobManager.ts` currently contains the logic for converting the final chromosome into `LectureSlot` records. This logic needs to be extracted into a dedicated, reusable decoder module as planned in Step 4.1.

## What Step 4.1 Needs to Accomplish

This step is focused on **separating the result decoding logic** from the job management orchestration. You will create a new `decoder.ts` module that is responsible for translating the GA's output (the best chromosome) into various usable formats.

### Core Objectives

1.  **Create a `decoder.ts` Module**: This new file will house all functions related to interpreting the final chromosome.
2.  **Implement `chromosomeToLectureSlots`**: Create a function that takes a `Chromosome` and `GAInputData` and returns an array of `LectureSlot` create-data objects, ready for Prisma. This will involve moving the existing logic from `persistResults` in `jobManager.ts` into this new function.
3.  **Refactor `jobManager.ts`**: Update `persistResults` to call the new decoder function instead of performing the conversion inline. This promotes separation of concerns.
4.  **Implement JSON Export Structure**: Create a function `chromosomeToJSON` that transforms the best chromosome into the hierarchical JSON format specified in Section 7.2 of the research document. This will be used for API responses and potentially for displaying results in the UI.
5.  **(Optional) Implement View-Specific Decoders**: If time permits, create helper functions to structure the decoded data for specific UI views (e.g., a grid view, a teacher-specific view).

## Implementation Strategy

1.  **Create `src/server/services/timetableGenerator/decoder.ts`**.
2.  **Move Logic**: Copy the mapping logic from the `persistResults` function in `jobManager.ts` into a new `chromosomeToLectureSlots` function in `decoder.ts`.
3.  **Update `jobManager.ts`**: Modify `persistResults` to import and use `chromosomeToLectureSlots`.
4.  **Implement JSON Decoder**: In `decoder.ts`, create the `chromosomeToJSON` function. You will need to use the `lookupMaps` from the `GAInputData` to get the full details (names, etc.) for lectures, teachers, rooms, and subdivisions to build the rich JSON structure.
5.  **Export**: Export all new functions from `decoder.ts` and update the main `index.ts` for the module.

## Gotchas & Important Considerations

- **Data Denormalization**: The JSON export requires denormalizing the data. You'll need to perform many lookups to get human-readable names for IDs. Ensure this is done efficiently.
- **Lecture Event IDs**: Remember that `gene.lectureEventId` is in the format `lectureId-evtX`. You will need to parse the base `lectureId` from this string.
- **Type Safety**: Ensure all your decoder functions are fully type-safe, using the interfaces from `types.ts`.
