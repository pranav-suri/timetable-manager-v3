# Next Step Instructions: Steps 2.4 & 2.5 - Crossover and Mutation

**For**: Agent implementing Steps 2.4 (Crossover with Repair) and 2.5 (Mutation)  
**Date**: October 29, 2025  
**Previous Steps**: 2.1-2.3 COMPLETE (Fitness, Initialization, Selection)  
**Current Focus**: Genetic operators for creating offspring with variation

## What You're Building

You're implementing the **core variation operators** that create new solutions by recombining and perturbing parent chromosomes. These operators are the engine of evolutionary search.

## Essential Context - Read These First

### 1. Review Completed Work (15 minutes)

**Initialization** (`initialization.ts`):

- Chromosomes are fixed-length arrays of genes
- Each gene: `{ lectureEventId, lectureId, timeslotId, classroomId, isLocked, duration }`
- `isLocked` genes must preserve their timeslotId (never modify!)
- eventIds array provides ordered mapping

**Selection** (`selection.ts`):

- `selectParentPairs()` returns array of [parent1Index, parent2Index]
- Use these indices to get actual chromosomes from population
- Each pair will produce offspring via crossover

**Fitness** (`fitness.ts`):

- `evaluateFitness()` to assess offspring quality
- Use after crossover and mutation to see if improvement occurred
- Optional: cache for performance

**Types** (`types.ts`):

- `GAConfig.crossoverProbability`: default 0.9 (90% chance)
- `GAConfig.mutationProbability`: default 0.05 (5% chance)
- `GAConfig.swapMutationRatio`: default 0.9 (90% swap, 10% random reset)
- `GAConfig.enableRepair`: default true

### 2. Core Concepts for Genetic Operators

**Crossover Purpose**:

- Combine genetic material from two parents
- Create offspring that inherit traits from both
- Exploration + exploitation balance
- May create constraint violations that need repair

**Mutation Purpose**:

- Introduce random variation for diversity
- Escape local optima
- Fine-tune solutions
- Prevent premature convergence

**Constraint Handling**:

- Crossover often creates invalid solutions (clashes)
- Repair mechanism fixes violations immediately
- Balance: repair improves feasibility, but don't over-repair (loses diversity)
- Mutations should be small enough to usually maintain feasibility

## Step 2.4: Crossover with Repair

### File to Create

`src/server/services/timetableGenerator/crossover.ts`

### Implementation Plan

#### 2.4.1: Uniform Crossover (Core Operator)

**Function Signature**:

```typescript
function uniformCrossover(
  parent1: Chromosome,
  parent2: Chromosome,
  config: GAConfig,
): [Chromosome, Chromosome];
```

**Algorithm**:

1. Create two empty offspring arrays (same length as parents)
2. For each gene index i:
   - If gene is locked in either parent: use locked version in both offspring
   - Else: randomly choose which parent contributes to each offspring
     - 50% chance: offspring1 gets parent1[i], offspring2 gets parent2[i]
     - 50% chance: offspring1 gets parent2[i], offspring2 gets parent1[i]
3. This creates two new chromosomes with mixed genes
4. Return both offspring

**Critical Details**:

- Locked genes MUST be handled specially - never swap locked assignments
- Each gene is independently selected (uniform crossover)
- Offspring have same length as parents (all genes present)
- Deep copy genes to avoid reference sharing

**Why Uniform Crossover?**
Research shows uniform crossover works better than single-point for timetabling because there's no positional bias (gene order doesn't represent time).

#### 2.4.2: Repair Mechanism

**File to Create**: `src/server/services/timetableGenerator/repair.ts`

**Function Signature**:

```typescript
function repairChromosome(
  chromosome: Chromosome,
  inputData: GAInputData,
  config: GAConfig,
): Chromosome;
```

**Repair Strategy** (Limited Attempts):

1. Evaluate chromosome to identify violations
2. Focus ONLY on hard constraint violations (clashes)
3. For each violation type:
   - **Teacher Clash**: Move one conflicting lecture to different slot
   - **Subdivision Clash**: Move one conflicting lecture to different slot
   - **Room Clash**: Change classroom OR change slot for one lecture
4. Maximum repair attempts: 10 per violation
5. After 10 attempts, give up (let fitness function penalize it)

**Repair Heuristic for Slot Reassignment**:

```typescript
// For a gene that causes clash:
// 1. Get all available slots
// 2. Try random slots until one doesn't create immediate clash
// 3. Check: teacher available? subdivision available? classroom available?
// 4. If yes: assign and move to next violation
// 5. If 10 attempts fail: leave as-is
```

**Important**: Don't over-repair! Goal is to reduce hard violations, not achieve perfection. Partial repair is acceptable.

#### 2.4.3: Crossover with Repair Integration

**Function Signature**:

```typescript
export function crossover(
  parent1: Chromosome,
  parent2: Chromosome,
  inputData: GAInputData,
  config: GAConfig,
): [Chromosome, Chromosome];
```

**Algorithm**:

1. Check `config.crossoverProbability`
   - If random() > crossoverProbability: return copies of parents (no crossover)
   - Else: proceed with crossover
2. Call `uniformCrossover(parent1, parent2, config)` to get offspring
3. If `config.enableRepair`:
   - Repair offspring1
   - Repair offspring2
4. Return repaired offspring

**Edge Cases**:

- If parents are identical: offspring will be identical (okay, mutation will diversify)
- If repair fails to fix all violations: acceptable, fitness will be low but evolution continues
- Very constrained problems: repair may struggle, that's expected

### Step 2.5: Mutation Operator

### File to Create (continue in crossover.ts or separate)

`src/server/services/timetableGenerator/mutation.ts`

### Implementation Plan

#### 2.5.1: Swap Mutation (Primary - 90%)

**Function Signature**:

```typescript
function swapMutation(
  chromosome: Chromosome,
  inputData: GAInputData,
): Chromosome;
```

**Algorithm**:

1. Select two random gene indices: i, j
2. Check if either gene is locked:
   - If both locked: skip mutation, return chromosome unchanged
   - If one locked: select different pair
   - If neither locked: proceed
3. Swap their assignments:
   - temp = chromosome[i].timeslotId and classroomId
   - chromosome[i] gets chromosome[j]'s assignments
   - chromosome[j] gets temp
4. Return mutated chromosome

**Why Swap?**
Swapping preserves overall structure while introducing local perturbation. Less disruptive than random reset, maintains building blocks.

#### 2.5.2: Random Reset Mutation (Secondary - 10%)

**Function Signature**:

```typescript
function randomResetMutation(
  chromosome: Chromosome,
  inputData: GAInputData,
): Chromosome;
```

**Algorithm**:

1. Select one random gene index
2. If gene is locked: skip mutation, return unchanged
3. Else: assign completely new random values:
   - timeslotId = random from inputData.slots
   - classroomId = random from allowedClassrooms for this lecture
4. Return mutated chromosome

**Why Random Reset?**
Introduces larger jumps in search space. Helps escape local optima. Used less frequently because it's more disruptive.

#### 2.5.3: Main Mutation Function

**Function Signature**:

```typescript
export function mutate(
  chromosome: Chromosome,
  inputData: GAInputData,
  config: GAConfig,
): Chromosome;
```

**Algorithm**:

1. Check `config.mutationProbability`:
   - If random() > mutationProbability: return chromosome unchanged
   - Else: proceed with mutation
2. Choose mutation strategy:
   - If random() < config.swapMutationRatio: use swapMutation
   - Else: use randomResetMutation
3. Return mutated chromosome

**Deep Copy Important**:
Always clone chromosome before mutation to avoid modifying parent!

```typescript
const mutated = JSON.parse(JSON.stringify(chromosome)); // Deep copy
// Then mutate mutated, not chromosome
```

## Critical Implementation Details

### Locked Gene Handling

**NEVER modify locked genes**:

```typescript
// Before any modification
if (gene.isLocked) {
  continue; // Skip this gene
}

// Or for swap mutation
if (chromosome[i].isLocked || chromosome[j].isLocked) {
  // Select different pair or skip
}
```

### Classroom Selection in Mutations

Use the helper from initialization:

```typescript
const allowedClassrooms =
  inputData.lookupMaps.lectureToAllowedClassrooms.get(lectureId) || [];
const randomClassroom =
  allowedClassrooms[Math.floor(Math.random() * allowedClassrooms.length)];
```

### Repair Conflict Detection

For checking if assignment creates clash:

```typescript
// Pseudo-code for repair validation
function wouldCreateClash(
  gene: Gene,
  newSlotId: string,
  inputData: GAInputData,
): boolean {
  // Check if teacher is unavailable
  const teacher = inputData.lookupMaps.eventToLecture.get(
    gene.lectureEventId,
  ).teacherId;
  if (inputData.lookupMaps.teacherUnavailable.get(teacher)?.has(newSlotId)) {
    return true;
  }
  // Similar checks for subdivision, classroom
  // For simplicity, can skip this and just try random slots
}
```

## Common Mistakes to Avoid

### Mistake 1: Modifying Parents

```typescript
// ❌ WRONG - modifies parent directly
function crossover(parent1, parent2) {
  parent1[0] = parent2[0]; // MUTATES PARENT!
}

// ✅ CORRECT - create new chromosomes
function crossover(parent1, parent2) {
  const offspring1 = parent1.map((gene) => ({ ...gene })); // Deep copy
}
```

### Mistake 2: Ignoring Locked Genes

```typescript
// ❌ WRONG - might mutate locked gene
gene.timeslotId = randomSlot();

// ✅ CORRECT - check first
if (!gene.isLocked) {
  gene.timeslotId = randomSlot();
}
```

### Mistake 3: Over-Repairing

```typescript
// ❌ WRONG - repair until perfect (infinite loop risk)
while (hasViolations(chromosome)) {
  repair(chromosome); // Could run forever!
}

// ✅ CORRECT - limited attempts
for (let attempt = 0; attempt < 10; attempt++) {
  if (!hasViolations(chromosome)) break;
  tryOneRepair(chromosome);
}
```

### Mistake 4: Probability Checks

```typescript
// ❌ WRONG - inverted logic
if (Math.random() < crossoverProbability) {
  return parents; // Should crossover here!
}

// ✅ CORRECT
if (Math.random() >= crossoverProbability) {
  return parents; // Don't crossover
}
// Do crossover here
```

## Testing Checklist

After implementation:

- [ ] Crossover produces two offspring of correct length
- [ ] Locked genes never change in offspring
- [ ] Crossover probability controls whether it happens
- [ ] Repair reduces (not eliminates) hard violations
- [ ] Swap mutation only affects two genes
- [ ] Random reset only affects one gene
- [ ] Mutation probability works correctly
- [ ] No parent chromosome modification (deep copy verified)
- [ ] TypeScript compiles: `npx tsc --noEmit`

## Expected Behavior

**Crossover**:

- ~90% of parent pairs produce offspring via crossover
- ~10% pass through unchanged
- Offspring initially may have 5-15 hard violations
- After repair: ~1-5 hard violations (not zero)

**Mutation**:

- ~5% of chromosomes mutated
- ~95% pass through unchanged
- Swap: maintains most structure, local change
- Random reset: may introduce 1-2 new violations

## Integration with Next Steps

After completing 2.4 and 2.5:

- Step 2.6 (Replacement) will combine offspring with elites
- Step 3.1 (Main Loop) will chain: selection → crossover → mutation → evaluation
- Full generational cycle will be operational

## Performance Targets

- Crossover: <5ms per pair
- Repair: <20ms per chromosome (with violations)
- Mutation: <1ms per chromosome
- Total for 100 offspring: <3 seconds

Good luck! These operators are the heart of the GA - quality implementation here = good convergence! 🧬
