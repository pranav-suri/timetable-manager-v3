# Next Step Instructions: Step 2.2 - Population Initialization

**For**: Agent implementing Step 2.2  
**Date**: October 29, 2025  
**Previous Step**: 2.1 (Fitness Function) - COMPLETE  
**Current Focus**: Population Initialization - Creating diverse initial solutions

## What You're Building

You're implementing the **Population Initialization** module that creates the starting generation of chromosomes. This is critical because a good initial population significantly impacts convergence speed. You'll implement both random and heuristic strategies.

## Essential Context - Read These First

### 1. Review Completed Work (10 minutes)

**Fitness Module** (`src/server/services/timetableGenerator/fitness.ts`):

- `evaluateFitness(chromosome, inputData, weights, cache?)` - evaluate single chromosome
- `evaluatePopulation(population, inputData, weights, cache?)` - batch evaluation
- `FitnessCache` class - you'll use this to evaluate your initial population
- `calculatePopulationStats(fitnessResults)` - get statistics after initialization

**Types** (`src/server/services/timetableGenerator/types.ts`):

- `Gene` interface: lectureEventId, lectureId, timeslotId, classroomId, isLocked, duration
- `Chromosome = Gene[]` - fixed length array
- `Population = Chromosome[]`
- `GAConfig` - contains populationSize (200), heuristicInitRatio (0.2)
- `GAInputData` - contains all lectures, slots, classrooms, and lookupMaps

**Data Loader** (`src/server/services/timetableGenerator/dataLoader.ts`):

- Provides `GAInputData` with all entities and lookup maps
- `inputData.eventIds` - array of all lecture event IDs to schedule
- `inputData.totalEvents` - total number of genes in chromosome
- `inputData.lookupMaps.lockedAssignments` - Map of pre-assigned slots

### 2. Core Concepts for Initialization

**Event ID Generation Pattern**:
From data loader, each lecture with count=N produces N event IDs:

- Lecture "lec123" with count=3 produces: ["lec123-evt0", "lec123-evt1", "lec123-evt2"]
- These are in `inputData.eventIds` array in the exact order they should appear in chromosome
- Each gene in chromosome corresponds to one event ID at the same index

**Locked Assignments**:

- Some events are pre-scheduled (from LectureSlot table)
- Check: `inputData.lookupMaps.lockedAssignments.get(lectureEventId)`
- If locked: MUST use the locked timeslotId (classroom may be optional)
- Set `gene.isLocked = true` for these genes

**Allowed Classrooms**:

- Not all classrooms are valid for all lectures (capacity, features)
- Use: `inputData.lookupMaps.lectureToAllowedClassrooms.get(lectureId)`
- Returns array of classroom IDs that satisfy capacity and feature requirements
- If empty or undefined: fallback to ALL classrooms (no restrictions)

**Available Slots**:

- Use all slots from `inputData.slots`
- Later, constraint checking will penalize unavailable assignments
- For initialization, any slot is technically valid (just may incur penalties)

## Implementation Plan

### Step 2.2.1: Random Chromosome Initialization

**File to Create**: `src/server/services/timetableGenerator/initialization.ts`

**Function Signature**:

```typescript
function initializeRandomChromosome(inputData: GAInputData): Chromosome;
```

**Algorithm**:

1. Create empty genes array with length = `inputData.totalEvents`
2. For each index i from 0 to totalEvents-1:
   - Get event ID: `eventId = inputData.eventIds[i]`
   - Get lecture: `lecture = inputData.lookupMaps.eventToLecture.get(eventId)`
   - Check if locked: `locked = inputData.lookupMaps.lockedAssignments.get(eventId)`
3. If locked assignment exists:
   - Use locked.slotId as timeslotId
   - Use locked.classroomId if present, else random from allowed
   - Set isLocked = true
4. If NOT locked:
   - Random timeslot: pick random from `inputData.slots` array
   - Random classroom: pick random from allowed classrooms for this lecture
   - Set isLocked = false

5. Create gene: `{ lectureEventId: eventId, lectureId: lecture.id, timeslotId, classroomId, isLocked, duration: lecture.duration }`

**Edge Cases**:

- If `lectureToAllowedClassrooms.get(lectureId)` is empty: use ALL classrooms
- If lecture is undefined: throw error (data integrity issue)
- Ensure random selection is uniform (use Math.floor(Math.random() \* array.length))

**Performance**: Should complete in <50ms for 200 events

### Step 2.2.2: Heuristic Chromosome Initialization

**Function Signature**:

```typescript
function initializeHeuristicChromosome(inputData: GAInputData): Chromosome;
```

**Greedy Heuristic Strategy**:

The heuristic should produce better-than-random solutions by scheduling constrained events first.

**Algorithm**:

1. Create array of event metadata: `{ eventId, lectureId, lecture, locked, numAllowedClassrooms }`
2. Sort by constraints (ascending):
   - Locked events first (they have no choice)
   - Then by number of allowed classrooms (fewest options first)
   - Then by lecture duration (longer lectures harder to place)

3. Initialize partial chromosome (all genes empty)
4. For each event in sorted order:
   - If locked: use locked assignment
   - Else: try to find best slot/classroom that minimizes conflicts
5. Conflict minimization strategy:
   - For each candidate slot:
     - Count how many already-scheduled genes conflict with this assignment
     - Conflicts: same teacher/subdivision/classroom at same time
   - Choose slot with fewest conflicts
   - If tie: random selection among tied options

6. Classroom selection:
   - From allowed classrooms, prefer ones not heavily used in chosen slot
   - Simple approach: pick random from allowed (full optimization can wait)

**Simplified Heuristic** (if above is too complex):
Just do random initialization but prioritize locked events and use a simple greedy rule:

- Schedule locked events first
- For others, try to spread events across available slots (avoid overloading early slots)

**Performance**: Should complete in <200ms for 200 events (more complex than random)

### Step 2.2.3: Population Initialization

**Function Signature**:

```typescript
function initializePopulation(
  config: GAConfig,
  inputData: GAInputData,
): Population;
```

**Algorithm**:

1. Calculate counts:
   - `heuristicCount = Math.floor(config.populationSize * config.heuristicInitRatio)`
   - `randomCount = config.populationSize - heuristicCount`

2. Generate heuristic chromosomes:
   - Loop heuristicCount times
   - Call `initializeHeuristicChromosome(inputData)`
   - Add to population array

3. Generate random chromosomes:
   - Loop randomCount times
   - Call `initializeRandomChromosome(inputData)`
   - Add to population array

4. Shuffle population:
   - Use Fisher-Yates shuffle to randomize order
   - This mixes heuristic and random chromosomes

5. Return population array

**Validation**:

- Assert: population.length === config.populationSize
- Assert: All chromosomes have length === inputData.totalEvents
- Log: "Initialized population: X heuristic, Y random"

### Step 2.2.4: Initial Population Evaluation

**Function Signature**:

```typescript
function evaluateInitialPopulation(
  population: Population,
  inputData: GAInputData,
  config: GAConfig,
): { fitnessResults: FitnessResult[]; stats: PopulationFitnessStats };
```

**Algorithm**:

1. Create new FitnessCache (from fitness.ts)
2. Call `evaluatePopulation(population, inputData, config.constraintWeights, cache)`
3. Calculate stats: `calculatePopulationStats(fitnessResults)`
4. Log statistics:
   - Best fitness, average fitness
   - Feasible count
   - Average hard/soft violations
5. Return both fitness results and stats

**Purpose**:
This provides immediate feedback on initialization quality and establishes baseline metrics.

## Critical Implementation Details

### Random Number Generation

For reproducibility, consider supporting seeded random:

```typescript
function getRandomInt(max: number, seed?: number): number {
  // If seed provided, use seeded PRNG
  // Else use Math.random()
  return Math.floor(Math.random() * max);
}
```

If implementing seed support:

- Store seed in config: `config.randomSeed`
- Use a simple LCG or seedrandom library
- Allows exact reproduction of results for debugging

### Locked Assignment Handling

**CRITICAL**: Always respect locked assignments:

```typescript
const lockedAssignment = inputData.lookupMaps.lockedAssignments.get(eventId);
if (lockedAssignment) {
  gene.timeslotId = lockedAssignment.slotId;
  gene.classroomId = lockedAssignment.classroomId || randomAllowedClassroom;
  gene.isLocked = true;
}
```

### Classroom Selection Logic

```typescript
// Get allowed classrooms for lecture
let allowedClassrooms =
  inputData.lookupMaps.lectureToAllowedClassrooms.get(lectureId);

// Fallback if no restrictions
if (!allowedClassrooms || allowedClassrooms.length === 0) {
  allowedClassrooms = inputData.classrooms.map((c) => c.id);
}

// Random selection
const randomIndex = Math.floor(Math.random() * allowedClassrooms.length);
const classroomId = allowedClassrooms[randomIndex]!;
```

## Common Mistakes to Avoid

### Mistake 1: Wrong Chromosome Length

```typescript
// ‚ùå WRONG - chromosome length must equal totalEvents
const chromosome: Chromosome = [];
for (const lecture of inputData.lectures) {
  chromosome.push(createGene(lecture)); // Only creates one gene per lecture!
}

// ‚úÖ CORRECT - use eventIds which already accounts for lecture.count
for (const eventId of inputData.eventIds) {
  chromosome.push(createGene(eventId));
}
```

### Mistake 2: Mutating Shared Data

```typescript
// ‚ùå WRONG - modifying lookup map
const allowedClassrooms =
  inputData.lookupMaps.lectureToAllowedClassrooms.get(lectureId);
allowedClassrooms.push(newClassroom); // MUTATES SHARED DATA!

// ‚úÖ CORRECT - create new array if needed
const allowedClassrooms = [
  ...(inputData.lookupMaps.lectureToAllowedClassrooms.get(lectureId) || []),
];
```

### Mistake 3: Not Using Lookup Maps

```typescript
// ‚ùå WRONG - O(n) search
const lecture = inputData.lectures.find((l) => l.id === lectureId);

// ‚úÖ CORRECT - O(1) lookup
const lecture = inputData.lookupMaps.eventToLecture.get(eventId);
```

### Mistake 4: Ignoring Locked Constraints

```typescript
// ‚ùå WRONG - might override locked assignment
gene.timeslotId = randomSlot();

// ‚úÖ CORRECT - check if locked first
if (!gene.isLocked) {
  gene.timeslotId = randomSlot();
}
```

## Testing Checklist

After implementation, verify:

- [ ] Population has exactly `config.populationSize` chromosomes
- [ ] Each chromosome has exactly `inputData.totalEvents` genes
- [ ] All genes have valid lectureEventId (from inputData.eventIds)
- [ ] All locked genes use their locked timeslotId
- [ ] All genes have classroomId from allowed list (or all classrooms if unrestricted)
- [ ] Heuristic chromosomes have lower average violations than random (run evaluation)
- [ ] No TypeScript errors: run `npx tsc --noEmit`
- [ ] Initialization completes in <5 seconds for population of 200

## Expected Output Example

After running initialization and evaluation:

```
Initializing population...
  Heuristic chromosomes: 40
  Random chromosomes: 160
  Total: 200

Evaluating initial population...
  Best fitness: 0.0234 (infeasible)
  Average fitness: 0.0089
  Worst fitness: 0.0034
  Feasible solutions: 0 / 200 (0%)
  Average hard violations: 23.4
  Average soft violations: 56.2

Initialization complete in 2.3s
```

Don't expect feasible solutions initially - that's normal! The GA will evolve them.

## Integration with Next Steps

After completing this step:

- Step 2.3 (Selection) will use your population and fitness results
- Step 2.6 (Replacement) will compare with this initial population
- Step 3.1 (Main Loop) will call `initializePopulation()` at the start

Make sure to export:

```typescript
export {
  initializePopulation,
  evaluateInitialPopulation,
  // Optional: export helpers if useful elsewhere
  initializeRandomChromosome,
  initializeHeuristicChromosome,
};
```

Good luck! This is the foundation of the entire GA - quality initialization = faster convergence! üöÄ
