# AI Coding Agent Instructions: Timetable Manager V3

## ðŸŽ¯ TL;DR - Current Project State (November 3, 2025)

**Status**: Production Ready - Timetable generation system COMPLETE âœ…

**What Works**:

- Generate conflict-free timetables using genetic algorithm
- Full CRUD for teachers, subjects, classrooms, lectures, groups, subdivisions
- Drag-and-drop timetable editor with real-time sync
- Material-UI v7 responsive design
- Type-safe API (tRPC) with optimistic updates

**Tech Stack**: React 19 + TanStack Router + TanStack DB Collections + tRPC + Prisma + SQLite

**Quick Commands**:

```bash
bun run dev              # Start dev server
bunx tsgo --noEmit        # Type check (MUST pass)
bun run check           # Format + lint auto-fix
bunx prisma studio      # Browse database
```

**Note**: This project does NOT have automated tests currently.
**Note**: This project uses Tanstack DB, this is a new library and patterns are documented in `memory-bank/tanstackDbDocs.md`.

**What's Next**: Preferred unavailability UI â†’ Export filtering â†’ Undo/Redo

---

## Project Identity & Purpose

**Educational timetable management system** for scheduling courses, teachers, classrooms, and student groups with automated constraint optimization. Built for universities/colleges to generate conflict-free course schedules.

## Architecture: The Big Picture

### Technology Stack (React 19 SSR)

- **Development**: Use Bun as the package manager and build tool
- **Frontend**: React 19 + Material-UI v7 (NOT Tailwind despite package.json)
- **Routing**: TanStack Router v1 (file-based, SSR-capable)
- **State**: TanStack DB Collections (optimistic updates) + Zustand (UI state)
- **API**: tRPC v11 (type-safe server procedures)
- **Database**: Prisma 6 + SQLite (split schema pattern)

### The Core Pattern: Collections â†’ tRPC â†’ Prisma

```
UI Component
    â†“ useCollections()
TanStack DB Collection (client-side cache + optimistic updates)
    â†“ onInsert/onUpdate/onDelete callbacks
tRPC Procedure (type-safe API)
    â†“ ctx.prisma
Prisma ORM
    â†“
SQLite Database
```

**Critical**: Data ALWAYS flows through collections. Direct tRPC usage in components is forbidden.

### Why Collections? (The "Why" Behind This Pattern)

Traditional React Query pattern causes stale data issues when switching between timetables. Collections solve this by:

1. Clearing cache on timetable change (`queryClient.clear()` in `CollectionProvider.tsx`)
2. Providing optimistic updates that auto-rollback on error
3. Centralizing mutation logic (no scattered `onSuccess` callbacks)
4. Enabling cross-component reactivity via `useLiveQuery`

## Essential Implementation Patterns

**See memory-bank/systemPatterns.md and README examples for detailed patterns**

Core rules:

1. Collections fetch data and handle database state
2. Always include collections in `useLiveQuery` deps
3. Register collections in `CollectionProvider.tsx`
4. **Route-Based File Organization**: Store feature-specific components, hooks, and utilities within the route directory using prefixed folders:
   - `-components/` for route-specific UI components
   - `-hooks/` for route-specific custom hooks
   - `-utils/` for route-specific utility functions
   - Example: `routes/tt/$timetableId/edit/export/{-components,-hooks,-utils}`
   - This keeps related code colocated and improves maintainability
5. Do not use useEffect for managing state derived from collections, derive directly into variables.

## Critical Workflows & Commands

### Development Cycle

```bash
bun run dev              # Start dev server (port 3000)
bunx tsgo --noEmit        # Type check (MUST pass before commit)
bun run check           # Format + lint (auto-fix)
bunx prisma studio       # Browse database visually
```

### After Schema Changes

```bash
# 1. Edit prisma/schema/*.prisma
# 2. Generate client
bunx prisma generate
# 3. Push to dev database
bunx prisma db push
# 4. Type check
bunx tsgo --noEmit
```

## Memory Bank System (Agent Continuity)

**Location**: `memory-bank/` directory

**Before any task**: Read these files in order:

1. `projectbrief.md` - Core requirements
2. `systemPatterns.md` - Architecture decisions
3. `activeContext.md` - Current work state
4. `tt-gen/steps.md` - Timetable algorithm implementation roadmap
5. `tanstackDbDocs.md` - TanStack DB patterns, must refer to this if going to use collections or `useLiveQuery`.

**After completing features**: Update `activeContext.md` and `progress.md`

### Quick Context Summary

**What's Done** âœ…

- Full timetable generation system (genetic algorithm, UI, job management)
- Complete CRUD interfaces for all entities (teachers, subjects, classrooms, lectures, groups, subdivisions)
- TanStack DB collections with optimistic updates
- Material-UI v7 integration (responsive design)
- Zero TypeScript errors

**What's Next** ðŸ”„

1. Preferred unavailability UI (soft constraints)
2. Advanced export/import with filtering
3. Undo/Redo (Ctrl+Z) for timetable edits
4. Loading state improvements

**Current Architecture**

- Collections â†’ tRPC â†’ Prisma â†’ SQLite
- UI uses `useLiveQuery` for reactive data updates
- Optimistic updates with automatic error rollback
- Split Prisma schema files in `prisma/schema/`

## Common Integration Points

See memory-bank/systemPatterns.md for detailed patterns:

- Cross-component data sharing with collections
- Form validation with Zod schemas
- Many-to-many relationships via junction tables

**Import pattern**: Use `config.ts` for DEFAULT_GA_CONFIG, not `types.ts`

## Known Gotchas & Solutions

### 1. Collection Not Updating UI

**Symptom**: Data changes but UI doesn't refresh
**Cause**: Missing collection in `useLiveQuery` dependency array
**Fix**: `useLiveQuery((q) => ..., [collection])` â† MUST include

### 2. TypeScript Errors After Schema Change

**Symptom**: Type errors referencing Prisma models
**Solution**: Run `bunx prisma generate` to regenerate types

### 3. Optimistic Update Not Rolling Back

**Symptom**: On error, UI shows stale data
**Cause**: Mutation handler caught error without re-throwing
**Fix**: Always `throw error` after logging in catch blocks

### 4. "Collection Not Found" Runtime Error

**Symptom**: `teacherCollection is undefined`
**Cause**: Forgot to add to `CollectionProvider.tsx`
**Fix**: Add `entityCollection: getEntityCollection(input)` to collections object

### 5. Route Not Found (404)

**Symptom**: Navigation fails with 404
**Cause**: Using wrong route prefix
**Fix**: Use `/tt/$timetableId/...` not `/timetable/$timetableId/...`

### 6. Collection Data Access

Refer to `memory-bank/tanstackDbDocs.md` for proper patterns.

## Support & Documentation

- **TanStack DB**: `memory-bank/tanstackDbDocs.md`
- **Architecture**: `memory-bank/systemPatterns.md`
- **Algorithm Work**: `memory-bank/tt-gen/steps.md`
- **Active Context**: `memory-bank/activeContext.md`

**When stuck**: Check Memory Bank first, then ask specific questions referencing relevant files.

```

```

## Quick Reference: File Locations

```
src/
â”œâ”€â”€ components/                        # Reusable UI components
â”‚   â”œâ”€â”€ Availability/                 # Unavailability editors (Teacher/Classroom/Subdivision)
â”‚   â”œâ”€â”€ Buttons/                      # Shared buttons (ToggleDarkMode, etc.)
â”‚   â”œâ”€â”€ Chatbot/                      # Chat interface components
â”‚   â”œâ”€â”€ CognitiveLoad/                # Load visualization
â”‚   â””â”€â”€ Generation/                   # Generation config & controls (7+ components)
â”‚
â”œâ”€â”€ db-collections/                    # TanStack DB Collections (optimistic updates)
â”‚   â”œâ”€â”€ providers/                    # CollectionProvider, context, hooks
â”‚   â”œâ”€â”€ availability/                 # Unavailability collections (3 types)
â”‚   â”œâ”€â”€ utils/                        # Error handling utilities
â”‚   â”œâ”€â”€ *Collection.tsx               # Entity collections (15+ files)
â”‚   â”œâ”€â”€ liveCollections.tsx           # Live query helpers
â”‚   â””â”€â”€ transactions.tsx              # Transaction utilities
â”‚
â”œâ”€â”€ routes/                            # File-based routing (TanStack Router)
â”‚   â”œâ”€â”€ __root.tsx, index.tsx         # App layout & home
â”‚   â”œâ”€â”€ api/                          # API routes (trpc endpoint, demo data)
â”‚   â”œâ”€â”€ demo/                         # Demo pages (TanStack Query examples)
â”‚   â””â”€â”€ tt/$timetableId/              # Timetable routes
â”‚       â”œâ”€â”€ index.tsx, route.tsx      # Dashboard & layout
â”‚       â”œâ”€â”€ edit/                     # Drag-and-drop editor
â”‚       â”‚   â”œâ”€â”€ index.tsx             # Main edit page component
â”‚       â”‚   â”œâ”€â”€ -components/          # Editor UI (9+ components)
â”‚       â”‚   â”œâ”€â”€ -conflictList/        # Conflict detection & display
â”‚       â”‚   â”œâ”€â”€ -hooks/               # Editor hooks (DnD, filtering)
â”‚       â”‚   â””â”€â”€ export/               # Export feature (colocated)
â”‚       â”‚       â”œâ”€â”€ -components/      # ExportButton.tsx
â”‚       â”‚       â”œâ”€â”€ -hooks/           # useExportTimetable.ts
â”‚       â”‚       â””â”€â”€ -utils/           # aggregateData.ts
â”‚       â”œâ”€â”€ generate.tsx, chatbot.tsx # Generation & AI chat
â”‚       â”œâ”€â”€ teachers.tsx, subjects.tsx, classrooms.tsx
â”‚       â”œâ”€â”€ lectures.tsx, groups.tsx, subdivisions.tsx
â”‚       â””â”€â”€ timetables.tsx            # Entity CRUD pages
â”‚
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ controllers/                  # Business logic
â”‚   â”‚   â””â”€â”€ sampleData/               # CSV import controllers
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ gemini/                   # AI chatbot service (Gemini)
â”‚   â”‚   â””â”€â”€ timetableGenerator/       # Genetic Algorithm (GA) engine
â”‚   â”‚       â”œâ”€â”€ constraints/          # Hard & soft constraints (18+ files)
â”‚   â”‚       â”œâ”€â”€ crossover/            # Crossover operators
â”‚   â”‚       â”œâ”€â”€ dataLoader/           # Data loading & lookup maps
â”‚   â”‚       â”œâ”€â”€ fitness/              # Fitness evaluation & caching
â”‚   â”‚       â”œâ”€â”€ initialization/       # Population initialization
â”‚   â”‚       â”œâ”€â”€ mutation/             # Mutation operators
â”‚   â”‚       â”œâ”€â”€ repair/               # Constraint repair strategies
â”‚   â”‚       â”œâ”€â”€ replacement/          # Replacement strategies
â”‚   â”‚       â”œâ”€â”€ selection/            # Selection operators
â”‚   â”‚       â”œâ”€â”€ utils/                # Grouping, memory monitoring
â”‚   â”‚       â”œâ”€â”€ algorithm.ts          # Main GA algorithm
â”‚   â”‚       â”œâ”€â”€ decoder.ts, validator.ts
â”‚   â”‚       â”œâ”€â”€ gaWorker.ts           # Worker thread implementation
â”‚   â”‚       â””â”€â”€ jobManager.ts         # Job queue management
â”‚   â”‚
â”‚   â”œâ”€â”€ trpc/
â”‚   â”‚   â”œâ”€â”€ routers/                  # tRPC procedures (20+ routers)
â”‚   â”‚   â”‚   â”œâ”€â”€ availability/         # Unavailability routers
â”‚   â”‚   â”‚   â”œâ”€â”€ *Router.ts            # Entity routers
â”‚   â”‚   â”‚   â”œâ”€â”€ generateRouter.ts     # Generation endpoint
â”‚   â”‚   â”‚   â””â”€â”€ chatbotRouter.ts      # Chatbot endpoint
â”‚   â”‚   â”œâ”€â”€ utils/                    # Ownership verification
â”‚   â”‚   â””â”€â”€ init.ts, errorLogger.ts   # tRPC setup & middleware
â”‚   â”‚
â”‚   â””â”€â”€ prisma.ts, utils/             # Prisma client & server utils
â”‚
â”œâ”€â”€ context/                           # React contexts (ThemeModeContext)
â”œâ”€â”€ hooks/                             # Custom hooks (useJobs)
â”œâ”€â”€ integrations/                      # tRPC client, providers, devtools
â”œâ”€â”€ zustand/                           # Zustand stores (5 stores)
â”œâ”€â”€ utils/                             # Utilities (cognitiveLoad, export, constants)
â”œâ”€â”€ env.ts, router.tsx                # Environment & routing config
â””â”€â”€ routeTree.gen.ts, styles.css      # Generated routes & styles

prisma/
â”œâ”€â”€ schema/                            # Split Prisma schemas (11+ entity files)
â”‚   â”œâ”€â”€ index.prisma
â”‚   â”œâ”€â”€ Teacher.prisma, Subject.prisma, Classroom.prisma
â”‚   â”œâ”€â”€ Lecture.prisma, Timetable.prisma, Slot.prisma # Lecture.prisma stores the lecture and slot mapping
â”‚   â”œâ”€â”€ Group.prisma, Subdivision.prisma
â”‚   â”œâ”€â”€ GenerationConfig.prisma, Job.prisma
â”‚   â””â”€â”€ User.prisma, Organization.prisma
â””â”€â”€ migrations/                        # Database migrations

generated/
â”œâ”€â”€ prisma/                            # Generated Prisma client
â””â”€â”€ zod/                               # Generated Zod schemas

memory-bank/                           # Agent memory system
â”œâ”€â”€ activeContext.md                   # Current state & priorities
â”œâ”€â”€ productContext.md                  # Product vision
â”œâ”€â”€ progress.md                        # Feature completion tracking
â”œâ”€â”€ projectbrief.md                    # Core requirements
â”œâ”€â”€ systemPatterns.md                  # Architecture patterns
â”œâ”€â”€ techContext.md                     # Tech stack details
â”œâ”€â”€ tanstackDbDocs.md                  # TanStack DB patterns
â””â”€â”€ tt-gen/                            # Timetable generation docs
    â”œâ”€â”€ steps.md                       # Algorithm roadmap
    â”œâ”€â”€ research.md                    # GA theory
    â””â”€â”€ README.md                      # Generation overview
```

**Important Config Files** (root): `vite.config.ts`, `tsconfig.json`, `prisma.config.ts`, `package.json`

## Anti-Patterns to Avoid

1. âŒ Using `trpc.entity.list.useQuery()` in components â†’ Use collections
2. âŒ Creating collections with internal `useLiveQuery` â†’ Collections are data sources
3. âŒ Using Tailwind classes â†’ This is Material-UI v7
4. âŒ Naming tRPC query as `getAll` â†’ Use `list`
5. âŒ Skipping `bunx tsgo --noEmit` before commit â†’ Breaks production build
6. âŒ Adding mutation handlers to read-only collections â†’ Causes runtime errors
7. âŒ Direct Prisma calls from components â†’ Bypasses cache/optimistic updates

## Support & Documentation

- **TanStack DB**: `memory-bank/tanstackDbDocs.md`
- **Architecture**: `memory-bank/systemPatterns.md`
- **Algorithm Work**: `memory-bank/tt-gen/steps.md`
- **Active Context**: `memory-bank/activeContext.md`
- **Existing Cline Memory**: `.clinerules` (agent continuity patterns)

**When stuck**: Check Memory Bank first, then ask specific questions referencing relevant files.

## Documentation Updates

Memory Bank updates occur when:
1. Discovering new project patterns
2. After implementing significant changes
3. When user requests with **update memory bank** (MUST review ALL files)
4. When context needs clarification

flowchart TD
    Start[Update Process]

    subgraph Process
        P1[Review ALL Files]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Document Insights & Patterns]

        P1 --> P2 --> P3 --> P4
    end

    Start --> Process

Note: When triggered by **update memory bank**, I MUST review every memory bank file, even if some don't require updates. Focus particularly on activeContext.md and progress.md as they track current state.

REMEMBER: After every memory reset, I begin completely fresh. The Memory Bank is my only link to previous work. It must be maintained with precision and clarity, as my effectiveness depends entirely on its accuracy.